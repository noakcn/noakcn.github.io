{"pages":[{"title":"","permalink":"http://noak.tech/about/index.html","text":"hello about"}],"posts":[{"title":"HTML 5 Canvas","permalink":"http://noak.tech/2017/03/31/Html5 Canvas/","text":"HTML 5 Canvas1&lt;canvas id=\"myCanvas\" width=\"200\" height=\"100\" style=\"border:1px solid #000000;\"&gt;&lt;/canvas&gt; 点击运行 &lt;canvas&gt;&lt;/canvas&gt;创建一个画布 本身没有绘图功能，需要搭配JavaScript来绘图 1234var c = document.getElementById(\"myCanvas\");//首先，找到&lt;canvas&gt;元素var ctx = c.getContext(\"2d\");//创建context对象ctx.fillStyle = \"#FF0000\";//颜色ctx.fillRect(0, 0, 150, 75); //大小 fillRect(x,y,width,height) 点击运行 Canvas坐标 canvas 的左上角坐标为 (0,0) Canvas - 路径 绘制一条斜线 12345var c = document.getElementById(\"myCanvas\");var ctx = c.getContext(\"2d\");ctx.moveTo(0,0); //moveTo(x,y) 定义线条开始坐标ctx.lineTo(200,100);//lineTo(x,y) 定义线条结束坐标ctx.stroke();//实际地绘制出通过 moveTo() 和 lineTo() 方法定义的路径。 点击运行 绘制一个圆 12345var c = document.getElementById(\"myCanvas\");var ctx = c.getContext(\"2d\");ctx.beginPath();ctx.arc(95,50,40,0,2*Math.PI);//arc(x,y,r,start,stop)ctx.stroke(); 点击运行 Canvas - 文本 1234var c = document.getElementById(\"myCanvas\");var ctx = c.getContext(\"2d\");ctx.font=\"30px Arial\"; //定义字体ctx.fillText(\"Hello World\",10,50);//绘制实心文字 fillText(text,x,y) 点击运行 1234var c = document.getElementById(\"myCanvas\");var ctx = c.getContext(\"2d\");ctx.font=\"30px Arial\";ctx.strokeText(\"Hello World\",10,50); 点击运行 Canvas - 渐变 线条渐变 12345678910var c = document.getElementById(\"myCanvas\");var ctx = c.getContext(\"2d\");//创建渐变var grd = ctx.createLinearGradient(0,0,200,0);//createLinearGradient(x,y,x1,y1) - 创建线条渐变grd.addColorStop(0,\"red\");grd.addColorStop(1,\"white\");//填充渐变ctx.fillStyle = grd;ctx.fillRect(10,10,150,80); 点击运行 径向/圆渐变 12345678910var c = document.getElementById(\"myCanvas\");var ctx = c.getContext(\"2d\");//创建渐变var grd = ctx.createRadialGradient(75,50,5,90,60,100);//createRadialGradient(x,y,r,x1,y1,r1) - 创建一个径向/圆渐变grd.addColorStop(0,\"red\");grd.addColorStop(1,\"white\");//填充渐变ctx.fillStyle = grd;ctx.fillRect(10,10,150,80); Canvas - 图像 把一副图像放置到画布上 12&lt;img width=\"220\" height=\"277\" src=\"http://om8bq99t5.bkt.clouddn.com/17-3-30/35361084-file_1490843381323_5aa4.png\" alt=\"图像\" id=\"scream\"&gt;&lt;canvas id=\"myCanvas\" width=\"250\" height=\"300\" style=\"border:1px solid #000000;\"&gt;&lt;/canvas&gt; 1234var c = document.getElementById(\"myCanvas\");var ctx = c.getContext(\"2d\");var img = document.getElementById(\"scream\");ctx.drawImage(img,10,10); //绘图 点击运行"},{"title":"","permalink":"http://noak.tech/2017/03/31/jquery 事件冒泡/","text":"jquery 事件冒泡tags:#java script 首先可以来看一个例子： 12345&lt;div id=\"dOne\" onclick=\"alert('我是最外层')\"&gt; &lt;div id=\"dTwo\" onclick=\"alert('我是中间层')\"&gt; &lt;a href=\"http://www.baidu.com\" id=\"aTree\" onclick=\"alert('我是最里层')\"&gt;click me&lt;/a&gt; &lt;/div&gt;&lt;/div&gt; 点击运行 上面这个示例分3层：dOne 最外面一层，dTwo中间层，a标签在最里层，他们各自有自己的onclick事件。 运行后会发现一次弹出我是最里层--&gt;我是中间层--&gt;我是最外层然后跳转到百度。 那么为什么会这样呢？ 这个就要讲讲jquery的事件冒泡了。 在一个对象上触发某类事件（比如单击事件），如果此对象定义了处理此事件的处理程序，那么此事件就会调用这个处理程序，如果没有定义出此事件的处理程序或者事件返回true，那么这个事件就会向这个对象的父级对象传播，从里到外，直至他被处理，或者到达对象层次的最顶层，即document对象（有些是window) 然而有时候这并不是我们所需要的,那该如何处理呢？ 我们可以阻止事件的冒泡行为。 event.stopPropagation(); 12345$(function() &#123; $(\"#aTree\").click(function(e) &#123; e.stopPropagation(); &#125;)&#125;) 点击运行 这时候就会发现只有 我是最里层被执行，然后跳转至百度，达到了阻止事件往外冒泡。 return false 12345$(function() &#123; $(\"#aTree\").click(function(e) &#123; return false; &#125;)&#125;) 点击运行 也是只有 我是最里层被执行，虽然阻止了事件往外冒泡，但是却不跳转百度。 event.preventDefault(); 12345$(function() &#123; $(\"#aTree\").click(function(e) &#123; e.preventDefault(); &#125;)&#125;) 点击运行 运行后依次出现我是最里层--&gt;我是中间层--&gt;我是最外层 但是不跳转百度 总结 event.stopPropagation(); 事件处理过程中，阻止了事件的冒泡，不会阻止默认行为。 return false; 事件处理过程中，阻止了事件的冒泡，但是也阻止了默认行为。 event.preventDefault(); 事件处理过程中，不阻止冒泡，但是阻止默认行为。"},{"title":"","permalink":"http://noak.tech/2017/03/31/缓存穿透/","text":"一、缓存穿透我们在项目中使用缓存的时候，可能出现 业务逻辑服务查询一个缓存key，发现没有就到DB中去查询结果，然后返回的时候没有把对应的结果设置进缓存。当有大量业务要查询这个key的时候，就会导致大量的查询穿透缓存到达DB进行查询，从而导致DB压力大增。 缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个存在的数据每次请求都要到存储层去查询，失去了缓存的意义。 有 很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。在数据魔方里，我们采用了一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。 二、并发缓存有时候如果网站并发访问高，一个缓存如果失效，可能出现多个进程同时查询DB，同时设置缓存的情况，如果并发确实很大，这也可能造成DB压力过大，还有缓存频繁更新的问题。 我现在的想法是对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询。这种情况和刚才说的预先设定值问题有些类似，只不过利用锁的方式，会造成部分请求等待。 三、缓存失效，缓存雪崩缓 存失效时的雪崩效应对底层系统的冲击非常可怕。遗憾的是，这个问题目前并没有很完美的解决方案。大多数系统设计者考虑用加锁或者队列的方式保证缓存的单线 程（进程）写，从而避免失效时大量的并发请求落到底层存储系统上。在数据魔方中，我们设计的缓存过期机制理论上能够将各个客户端的数据失效时间均 匀地分布在时间轴上，一定程度上能够避免缓存同时失效带来的雪崩效应。"},{"title":"Hello World","permalink":"http://noak.tech/2017/03/31/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]}